Imagine a data-class & serialization package with:

- **NO** nasty boilerplate code
- **NO** minified/uglified generated files
- **NO** workarounds or compromises

while being able to

- **decode & encode** json
- come with built-in **type & null-safety**
- be **fully configurable**
- support **custom types**, **generics**, **polymorphism** and more.

Sounds too good to be true? Not anymore.

---

<p align="center">
  <a href="#quick-start">Quickstart</a> •
  <a href="https://pub.dev/documentation/dart_mappable/latest/topics/Introduction-topic.html">Documentation</a> •
  <a href="https://pub.dev/packages/dart_mappable/example">Example</a> •
  <a href="https://github.com/schultek/dart_mappable/tree/main/examples/json_serializable_compare">Feature Comparison</a> •
  <a href="https://github.com/schultek/dart_mappable">Github</a>
</p>

`dart_mappable` is an **improved json serialization and data-class** package that can replace 
similar packages like `json_serializable`. 

It covers all basic features *(from/to json, == override, toString() override, ...)* 
while adding new or improved support for **advances use-cases like generics, inheritance and customization**.

## Quick Start

First, add `dart_mappable` as a dependency, together with `dart_mappable_builder` and `build_runner` as a dev_dependency.

```shell script
flutter pub add dart_mappable
flutter pub add build_runner --dev
flutter pub add dart_mappable_builder --dev
```

---

Next annotate your classes that you want to use with `@MappableClass()` and add the 
appropriate `part` directive to include the generated `.mapper.dart` file:

```dart
// This file is "model.dart"
import 'package:dart_mappable/dart_mappable.dart';

// Will be generated by dart_mappable
part 'model.mapper.dart';

@MappableClass()
class MyClass with MyClassMappable {
  final int myValue;
  
  MyClass(this.myValue);
}
```

To use a class you must:

- annotate the class with `@MappableClass()` and
- apply a mixin with the name of the class plus `Mappable`.

***Tip**: Don't worry if the mixin don't exist at first, just run code-generation once an it will be created.
The builder will also warn you if you define your class without the proper mixin.*

***Note**: For generic classes (e.g. `MyClass<T>`) make sure to also provide all type parameters 
to the mixin (`... with MyClassMappable<T>`).*

---

In order to generate the serialization code, run the following command:

```shell script
dart pub run build_runner build
```

***Tip**: You'll need to re-run code generation each time you are making changes to your annotated classes.
During development, you can use `watch` to automatically watch your changes: `dart pub run build_runner watch`.*

This will generate a `<filename>.mapper.dart` file for each of your files containing annotated classes.

---

Last step is to use the generated mappers. There are two main ways to interact with your models 
using this package: 

1. Through the generated `<ClassName>Mapper` classes, and 
2. through the methods defined by the generated mixin.

```dart
...

void main() {
  // Decode a [Map] using the [MyClassMapper] class:
  var myClass = MyClassMapper.fromMap({'myValue': 123});
  
  // Or decode directly from json:
  var myClass2 = MyClassMapper.fromJson('{"myValue": 123}');
  
  // Encode an instance of your class using the methods provided by the mixin:
  var json = myClass.toJson(); // or .toMap()

  // There are also implementations generated for [operator ==], [hashCode] and [toString]:
  var thisIsTrue = (myClass == myClass2);
  print(myClass);
  
  // Last you can use [copyWith] to create a copy of an object:
  var myClass3 = myClass.copyWith(myValue: 0);
}
```

## Overview

To setup, annotate your model classes with `@MappableClass()` and your enums with `@MappableEnum()`. 
Each annotation has a set of properties to configure the generated code.

```dart
@MappableClass()
class MyClass with MyClassMappable { ... }

@MappableEnum()
enum MyEnum { ... }
```

***Tip**: Check out the documentation about 
[Models](https://pub.dev/documentation/dart_mappable/latest/topics/Models-topic.html) and 
[Enums](https://pub.dev/documentation/dart_mappable/latest/topics/Enums-topic.html).*

For deserialization, `dart_mappable` will use the first available constructor of a class, but you
can use a specific constructor using the `@MappableConstructor()` annotation.

```dart
@MappableClass()
class MyClass with MyClassMappable {
  MyClass(); // Don't use this
  
  @MappableConstructor()
  MyClass.special(); // Use this
}
```

You can also annotate a single field or constructor parameter of a class using `@MappableField()`
to set a specific json key or add custom hooks.

```dart
@MappableClass()
class MyClass with MyClassMappable {
  MyClass(this.value);

  @MappableField(key: 'my_key')
  String value;
}
```

***Note**: This can only be used on a field if it is directly assigned as a constructor parameter (`MyClass(this.myField)`).
Setting this annotation on any other field will have no effect.
(Read [Utilizing Constructors](https://pub.dev/documentation/dart_mappable/latest/topics/Models-topic.html#utilizing-constructors) for an explanation why this is.)*

***Tip**: Hooks are a way to customize the serialization of any field or class.
Read more in the documentation about [Mapping Hooks](https://pub.dev/documentation/dart_mappable/latest/topics/Mapping%20Hooks-topic.html).*

You can add the `@MappableLib()` annotation to your `library` statement to set a default configuration
for all included classes and enums, e.g. the case style for json keys.

```dart
@MappableLib(caseStyle: CaseStyle.camelCase) // will be applied to all classes
library model;

part 'model.mapper.dart';

@MappableClass() // no need to set caseStyle here
class MyClass with MyClassMappable {
  ...
}
```

***Tip**: Check out the documentation to see all available [Configuration](https://pub.dev/documentation/dart_mappable/latest/topics/Configuration-topic.html) options.*

---

Here are again all **six** annotations that you can use in your code:

1. `@MappableClass()` can be used on a class to specify options like the `caseStyle` of the json keys, whether to ignore null values, or [hooks](https://pub.dev/documentation/dart_mappable/latest/topics/Mapping%20Hooks-topic.html).
2. `@MappableConstructor()` can be used on a constructor to mark this to be used for decoding. It has no properties.
3. `@MappableField()` can be used on a constructor parameter or a field to specify a json key to be used instead of the field name, or [hooks](https://pub.dev/documentation/dart_mappable/latest/topics/Mapping%20Hooks-topic.html).
4. `@MappableEnum()` can be used on an enum to specify the `mode` or `caseStyle` of the encoded enum values, or the `defaultValue`.
5. `@MappableValue()` can be used on an enum value to specify a custom encoded value to use.
6. `@MappableLib()` can be used on a library statement or import / export statement to set a default configuration for the annotated library or include / exclude classes.

### Mapper Interface

`dart_mappable` will generate `Mapper` classes that provide these methods or properties:

- `<ClassName>Mapper.fromMap<T>(Map<String, dynamic> map)` will take an encoded map object and return a decoded object of type `ClassName`.
- `<ClassName>Mapper.fromJson<T>(String json)` internally uses `fromMap` but works with json encoded `String`s.
- `<ClassName>Mapper.container` exposes the internal [`MapperContainer`](https://pub.dev/documentation/dart_mappable/latest/topics/Mapper%20Container-topic.html) for more advanced uses.

***Tip**: If you prefer to use `MyClass.fromJson` over `MyClassMapper.fromJson`, add the `fromJson` and 
`fromMap` methods directly to your class like this:*

```
class MyClass with MyClassMappable {
  ...

 static final fromMap = PersonMapper.fromMap;
 static final fromJson = PersonMapper.fromJson;
}
```

The generated `<ClassName>Mappable` mixin will come with the following methods:

- `toMap()` and `toJson()`.
- `copyWith()` to create copies of your class instance (see [Copy With](https://pub.dev/documentation/dart_mappable/latest/topics/Copy-With-topic.html)).
- overrides for `operator ==`, `hashCode` and `toString()`.

## Full Documentation

See the full documentation [here](https://pub.dev/documentation/dart_mappable/latest/topics/Introduction-topic.html)
or jump directly to the topic you are looking for:

- [**Models**](https://pub.dev/documentation/dart_mappable/latest/topics/Models-topic.html)
- [**Enums**](https://pub.dev/documentation/dart_mappable/latest/topics/Enums-topic.html)
- [**Configuration**](https://pub.dev/documentation/dart_mappable/latest/topics/Configuration-topic.html)
- [**Copy-With**](https://pub.dev/documentation/dart_mappable/latest/topics/Copy-With-topic.html)
- [**Polymorphism**](https://pub.dev/documentation/dart_mappable/latest/topics/Polymorphism-topic.html)
- [**Mapping Hooks**](https://pub.dev/documentation/dart_mappable/latest/topics/Mapping%20Hooks-topic.html)
- [**Custom Mappers**](https://pub.dev/documentation/dart_mappable/latest/topics/Custom%20Mappers-topic.html)
- [**Mapper Container**](https://pub.dev/documentation/dart_mappable/latest/topics/Mapper%20Container-topic.html)

## Compatibility

This package aims to be compatible with other code-generation packages. Check the `examples` directory for some common use-cases.

### Freezed

[Freezed](https://pub.dev/packages/freezed) is a "code generator for unions/pattern-matching/copy";
With this package, it is easy to create union or sealed classes.

Here is a simple example taken from their documentation:

```dart
part 'myfile.freezed.dart';

@freezed
class Union with _$Union {
  const factory Union(int value) = Data;
  const factory Union.loading() = Loading;
  const factory Union.error([String? message]) = ErrorDetails;
}
```

To make it compatible with dart_mappable, just add your `@MappableClass` annotations to both the parent class, and all **factory constructors**, as if they were the child classes.
For a description of the `discriminatorKey` and `discriminatorValue` properties refer to the [Polymorphism](https://pub.dev/documentation/dart_mappable/latest/topics/Polymorphism-topic.html) documentation.
You can also add the `@MappableField()` annotation to any of the fields.

```dart
part 'myfile.freezed.dart';
part 'myfile.mapper.dart';

@freezed
@MappableClass(discriminatorKey: 'type')
class Union with _$Union {
  @MappableClass(discriminatorValue: 'data')
  const factory Union.data(@MappableField(key: 'mykey') int value) = Data;
  @MappableClass(discriminatorValue: 'loading')
  const factory Union.loading() = Loading;
  @MappableClass(discriminatorValue: 'error')
  const factory Union.error([String? message]) = ErrorDetails;
}
```

This will now allow you to use this and the resulting `Data`, `Loading` and `ErrorDetails` classes as usual:

```dart
void main() {
  var data = Union.data(42);

  var dataJson = data.toJson();
  print(dataJson); // {"mykey":42,"type":"data"}

  var parsedData = UnionMapper.fromJson(dataJson);
  print(parsedData); // Union.data(value: 42)
}
```

For the full example and generated files, check out the `examples/example_freezed` directory.